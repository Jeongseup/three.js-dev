<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive - voxel painter</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			- voxel painter - webgl<br />
			<strong>click</strong>: add voxel, <strong>shift + click</strong>: remove
			voxel
		</div>

		<script type="module">
			import * as THREE from "../build/three.module.js";

			import Stats from "./jsm/libs/stats.module.js";
			import { GUI } from "./jsm/libs/dat.gui.module.js";
			import { OrbitControls } from "./jsm/controls/OrbitControls.js";
			import { GLTFLoader } from "./jsm/loaders/GLTFLoader.js";

			let camera, scene, renderer;
			let plane;
			let pointer,
				raycaster,
				isShiftDown = false;

			let rollOverMesh, rollOverMaterial;
			let cubeGeo, cubeMaterial;

			let model, skeleton, mixer, clock;

			const crossFadeControls = [];

			let currentBaseAction = "idle";
			const allActions = [];
			const baseActions = {
				idle: { weight: 1 },
				walk: { weight: 0 },
				run: { weight: 0 },
			};
			const additiveActions = {
				sneak_pose: { weight: 0 },
				sad_pose: { weight: 0 },
				agree: { weight: 0 },
				headShake: { weight: 0 },
			};
			let panelSettings, numAnimations;

			const objects = [];

			init();
			function init() {
				camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					1,
					10000
				);
				camera.position.set(500, 800, 1300);
				camera.lookAt(0, 0, 0);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xf0f0f0);

				// roll-over helpers

				const rollOverGeo = new THREE.BoxGeometry(50, 50, 50);
				rollOverMaterial = new THREE.MeshBasicMaterial({
					color: 0xff0000,
					opacity: 0.5,
					transparent: true,
				});
				rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
				scene.add(rollOverMesh);

				// cubes

				cubeGeo = new THREE.BoxGeometry(50, 50, 50);
				cubeMaterial = new THREE.MeshLambertMaterial({
					color: 0xfeb74c,
					map: new THREE.TextureLoader().load(
						"textures/square-outline-textured.png"
					),
				});

				// grid

				const gridHelper = new THREE.GridHelper(1000, 20);
				scene.add(gridHelper);

				//

				raycaster = new THREE.Raycaster();
				pointer = new THREE.Vector2();

				const geometry = new THREE.PlaneGeometry(1000, 1000);
				geometry.rotateX(-Math.PI / 2);

				plane = new THREE.Mesh(
					geometry,
					new THREE.MeshBasicMaterial({ visible: false })
				);
				scene.add(plane);

				objects.push(plane);

				// lights

				const ambientLight = new THREE.AmbientLight(0x606060);
				scene.add(ambientLight);

				const directionalLight = new THREE.DirectionalLight(0xffffff);
				directionalLight.position.set(1, 0.75, 0.5).normalize();
				scene.add(directionalLight);

				const loader = new GLTFLoader();
				loader.load("models/gltf/Xbot.glb", function (gltf) {
					model = gltf.scene;

					model.scale.set(100, 100, 100);

					scene.add(model);

					model.traverse(function (object) {
						if (object.isMesh) object.castShadow = true;
					});

					skeleton = new THREE.SkeletonHelper(model);
					skeleton.visible = false;
					scene.add(skeleton);

					const animations = gltf.animations;
					mixer = new THREE.AnimationMixer(model);

					numAnimations = animations.length;

					for (let i = 0; i !== numAnimations; ++i) {
						let clip = animations[i];
						const name = clip.name;

						if (baseActions[name]) {
							const action = mixer.clipAction(clip);
							activateAction(action);
							baseActions[name].action = action;
							allActions.push(action);
						} else if (additiveActions[name]) {
							// Make the clip additive and remove the reference frame

							THREE.AnimationUtils.makeClipAdditive(clip);

							if (clip.name.endsWith("_pose")) {
								clip = THREE.AnimationUtils.subclip(clip, clip.name, 2, 3, 30);
							}

							const action = mixer.clipAction(clip);
							activateAction(action);
							additiveActions[name].action = action;
							allActions.push(action);
						}
					}

					animate();
				});

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				document.addEventListener("pointermove", onPointerMove);
				document.addEventListener("pointerdown", onPointerDown);
				document.addEventListener("keydown", onDocumentKeyDown);
				document.addEventListener("keyup", onDocumentKeyUp);

				//

				window.addEventListener("resize", onWindowResize);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onPointerMove(event) {
				pointer.set(
					(event.clientX / window.innerWidth) * 2 - 1,
					-(event.clientY / window.innerHeight) * 2 + 1
				);

				raycaster.setFromCamera(pointer, camera);

				const intersects = raycaster.intersectObjects(objects);

				if (intersects.length > 0) {
					const intersect = intersects[0];

					rollOverMesh.position
						.copy(intersect.point)
						.add(intersect.face.normal);
					rollOverMesh.position
						.divideScalar(50)
						.floor()
						.multiplyScalar(50)
						.addScalar(25);
				}

				render();
			}

			function onPointerDown(event) {
				pointer.set(
					(event.clientX / window.innerWidth) * 2 - 1,
					-(event.clientY / window.innerHeight) * 2 + 1
				);

				raycaster.setFromCamera(pointer, camera);

				const intersects = raycaster.intersectObjects(objects);

				if (intersects.length > 0) {
					const intersect = intersects[0];

					// delete cube

					if (isShiftDown) {
						if (intersect.object !== plane) {
							scene.remove(intersect.object);

							objects.splice(objects.indexOf(intersect.object), 1);
						}

						// create cube
					} else {
						const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
						voxel.position.copy(intersect.point).add(intersect.face.normal);
						voxel.position
							.divideScalar(50)
							.floor()
							.multiplyScalar(50)
							.addScalar(25);
						scene.add(voxel);

						objects.push(voxel);
					}

					render();
				}
			}

			function onDocumentKeyDown(event) {
				switch (event.keyCode) {
					case 16:
						isShiftDown = true;
						break;
				}
			}

			function onDocumentKeyUp(event) {
				switch (event.keyCode) {
					case 16:
						isShiftDown = false;
						break;
				}
			}

			function render() {
				renderer.render(scene, camera);
			}

			function animate() {
				// Render loop

				requestAnimationFrame(animate);

				for (let i = 0; i !== numAnimations; ++i) {
					const action = allActions[i];
					const clip = action.getClip();
					const settings = baseActions[clip.name] || additiveActions[clip.name];
					settings.weight = action.getEffectiveWeight();
				}

				// Get the time elapsed since the last frame, used for mixer update

				const mixerUpdateDelta = clock.getDelta();

				// Update the animation mixer, the stats panel, and render this frame

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
