<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive - voxel painter</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
			input {
				width: 350px;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<button id="abc">메타마스크 연결</button>
			<input type="text" id="meta" disabled />
			<button id="getContract">컨트랙트 연결</button>
			<input type="text" id="contract" disabled />
			<br />
			가격<input type="number" id="price" disabled /><br />
			<strong>click</strong>: add voxel, <strong>shift + click</strong>: remove
			voxel
			<br />
		</div>

		<script type="module">
			import * as THREE from "../build/three.module.js";
			import { OrbitControls } from "./jsm/controls/OrbitControls.js";
			import {
				CSS2DRenderer,
				CSS2DObject,
			} from "./jsm/renderers/CSS2DRenderer.js";
			import Stats from "./jsm/libs/stats.module.js";
			import { GUI } from "./jsm/libs/dat.gui.module.js";
			import { GLTFLoader } from "./jsm/loaders/GLTFLoader.js";
			import {} from "./lib/web3.min.js";

			let camera, scene, renderer, labelRenderer;

			let plane;
			let pointer,
				raycaster,
				isShiftDown = false;

			let rollOverMesh, rollOverMaterial;
			let cubeGeo, cubeMaterial;

			const objects = [];
			let model, skeleton, mixer, clock;

			let provider;
			let web3;
			let account;
			let contract;

			init();
			render();

			async function abc() {
				console.log("안녕");
				if (window.ethereum) {
					web3 = new Web3(window.ethereum);
					try {
						// Request account access if needed
						await window.ethereum.enable();
						// Acccounts now exposed
						web3.eth.getAccounts().then(function (accounts) {
							account = accounts[0];
							document.getElementById("meta").value = account;
						});
					} catch (error) {}
				}
				// Legacy dapp browsers...
				else if (window.web3) {
					// Use Mist/MetaMask's provider.
					web3 = window.web3;
					console.log("Injected web3 detected.");
				}
			}

			async function getContract() {
				console.log("연결");
				let abi = [
					{
						inputs: [],
						stateMutability: "nonpayable",
						type: "constructor",
					},
					{
						inputs: [],
						name: "allCubeLimit",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [],
						name: "cubeBuy",
						outputs: [],
						stateMutability: "payable",
						type: "function",
					},
					{
						inputs: [],
						name: "cubeId",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [],
						name: "cubeLimit",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [],
						name: "cubePrice",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						name: "cubeToOwner",
						outputs: [
							{
								internalType: "address",
								name: "",
								type: "address",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [
							{
								internalType: "address",
								name: "",
								type: "address",
							},
						],
						name: "ownerCubeCount",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [
							{
								internalType: "uint256",
								name: "_cubeLimit",
								type: "uint256",
							},
						],
						name: "setCubeLimit",
						outputs: [],
						stateMutability: "nonpayable",
						type: "function",
					},
					{
						inputs: [
							{
								internalType: "uint256",
								name: "_cubePrice",
								type: "uint256",
							},
						],
						name: "setCubePrice",
						outputs: [],
						stateMutability: "nonpayable",
						type: "function",
					},
					{
						inputs: [],
						name: "withId",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						name: "withToCubeId",
						outputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						stateMutability: "view",
						type: "function",
					},
					{
						inputs: [
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
							{
								internalType: "uint256",
								name: "",
								type: "uint256",
							},
						],
						name: "withToOwnerAddress",
						outputs: [
							{
								internalType: "address",
								name: "",
								type: "address",
							},
						],
						stateMutability: "view",
						type: "function",
					},
				];
				contract = new web3.eth.Contract(
					abi,
					"0x9665F1ef2eCDA3030e1256e515d36BA2510DF373"
				);
				document.getElementById("contract").value = contract._address;
				console.log(contract);
				// // // listen event
				// contract.events.buyAddress({}, function(error, event){
				//   console.log(event)
				//   document.getElementById("eventResult").innerText = "선정된 판매자" + event.returnValues.seller;
				// })
				// document.getElementById("eventResult").innerText = "Listening..."
				let price = await contract.methods.cubePrice().call();
				document.getElementById("price").value = price;
			}

			function init() {
				camera = new THREE.PerspectiveCamera(
					45,
					window.innerWidth / window.innerHeight,
					1,
					10000
				);
				camera.position.set(500, 800, 1300);
				camera.lookAt(0, 0, 0);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xf0f0f0);

				// roll-over helpers

				const rollOverGeo = new THREE.BoxGeometry(50, 50, 50);
				rollOverMaterial = new THREE.MeshBasicMaterial({
					color: 0xff0000,
					opacity: 0.5,
					transparent: true,
				});
				rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
				scene.add(rollOverMesh);

				// cubes

				cubeGeo = new THREE.BoxGeometry(50, 50, 50);
				cubeMaterial = new THREE.MeshLambertMaterial({
					color: 0xfeb74c,
					map: new THREE.TextureLoader().load(
						"textures/square-outline-textured.png"
					),
				});

				// grid

				const gridHelper = new THREE.GridHelper(1000, 20);
				scene.add(gridHelper);

				//

				raycaster = new THREE.Raycaster();
				pointer = new THREE.Vector2();

				const geometry = new THREE.PlaneGeometry(1000, 1000);
				geometry.rotateX(-Math.PI / 2);

				plane = new THREE.Mesh(
					geometry,
					new THREE.MeshBasicMaterial({ visible: false })
				);
				scene.add(plane);

				objects.push(plane);

				// lights

				const ambientLight = new THREE.AmbientLight(0x606060);
				scene.add(ambientLight);

				const directionalLight = new THREE.DirectionalLight(0xffffff);
				directionalLight.position.set(1, 0.75, 0.5).normalize();
				scene.add(directionalLight);

				const loader = new GLTFLoader();
				loader.load("models/gltf/knight/KnightCharacter.gltf", function (gltf) {
					model = gltf.scene;

					model.scale.set(20, 20, 20);

					scene.add(model);

					model.traverse(function (object) {
						if (object.isMesh) object.castShadow = true;
					});

					skeleton = new THREE.SkeletonHelper(model);
					skeleton.visible = false;
					scene.add(skeleton);

					const animations = gltf.animations;
					mixer = new THREE.AnimationMixer(model);

					numAnimations = animations.length;

					for (let i = 0; i !== numAnimations; ++i) {
						let clip = animations[i];
						const name = clip.name;

						if (baseActions[name]) {
							const action = mixer.clipAction(clip);
							activateAction(action);
							baseActions[name].action = action;
							allActions.push(action);
						} else if (additiveActions[name]) {
							// Make the clip additive and remove the reference frame

							THREE.AnimationUtils.makeClipAdditive(clip);

							if (clip.name.endsWith("_pose")) {
								clip = THREE.AnimationUtils.subclip(clip, clip.name, 2, 3, 30);
							}

							const action = mixer.clipAction(clip);
							activateAction(action);
							additiveActions[name].action = action;
							allActions.push(action);
						}
					}

					animate();
				});

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				document.addEventListener("pointermove", onPointerMove);
				document.addEventListener("pointerdown", onPointerDown);
				document.addEventListener("keydown", onDocumentKeyDown);
				document.addEventListener("keyup", onDocumentKeyUp);

				labelRenderer = new CSS2DRenderer();
				labelRenderer.setSize(window.innerWidth, window.innerHeight);
				labelRenderer.domElement.style.position = "absolute";
				labelRenderer.domElement.style.top = "0px";
				document.body.appendChild(labelRenderer.domElement);

				const controls = new OrbitControls(camera, labelRenderer.domElement);
				controls.minDistance = 500;
				controls.maxDistance = 1800;
				//

				window.addEventListener("resize", onWindowResize);
				document.getElementById("abc").addEventListener("click", abc);
				document
					.getElementById("getContract")
					.addEventListener("click", getContract);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onPointerMove(event) {
				pointer.set(
					(event.clientX / window.innerWidth) * 2 - 1,
					-(event.clientY / window.innerHeight) * 2 + 1
				);

				raycaster.setFromCamera(pointer, camera);

				const intersects = raycaster.intersectObjects(objects);

				if (intersects.length > 0) {
					const intersect = intersects[0];

					rollOverMesh.position
						.copy(intersect.point)
						.add(intersect.face.normal);
					rollOverMesh.position
						.divideScalar(50)
						.floor()
						.multiplyScalar(50)
						.addScalar(25);
				}

				render();
			}

			function onPointerDown(event) {
				pointer.set(
					(event.clientX / window.innerWidth) * 2 - 1,
					-(event.clientY / window.innerHeight) * 2 + 1
				);

				raycaster.setFromCamera(pointer, camera);

				const intersects = raycaster.intersectObjects(objects);

				if (intersects.length > 0) {
					const intersect = intersects[0];

					// delete cube

					if (isShiftDown) {
						if (intersect.object !== plane) {
							scene.remove(intersect.object);

							objects.splice(objects.indexOf(intersect.object), 1);
						}

						// create cube
					} else {
						contract.methods
							.cubeBuy()
							.send({
								from: account,
								value: document.getElementById("price").value,
							})
							.then(function (result) {
								console.log(result);
								const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
								voxel.position.copy(intersect.point).add(intersect.face.normal);
								voxel.position
									.divideScalar(50)
									.floor()
									.multiplyScalar(50)
									.addScalar(25);
								scene.add(voxel);

								objects.push(voxel);
							});
					}

					render();
				}
			}

			function onDocumentKeyDown(event) {
				switch (event.keyCode) {
					case 16:
						isShiftDown = true;
						break;
				}
			}

			function onDocumentKeyUp(event) {
				switch (event.keyCode) {
					case 16:
						isShiftDown = false;
						break;
				}
			}

			function render() {
				renderer.render(scene, camera);
			}

			function animate() {
				// Render loop

				requestAnimationFrame(animate);

				for (let i = 0; i !== numAnimations; ++i) {
					const action = allActions[i];
					const clip = action.getClip();
					const settings = baseActions[clip.name] || additiveActions[clip.name];
					settings.weight = action.getEffectiveWeight();
				}

				// Get the time elapsed since the last frame, used for mixer update

				const mixerUpdateDelta = clock.getDelta();

				// Update the animation mixer, the stats panel, and render this frame

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
